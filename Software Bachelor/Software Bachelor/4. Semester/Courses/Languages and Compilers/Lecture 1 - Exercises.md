# Exercises
1.  Do Sebesta Review Questions 1 to 29 on page 54 and 55 give priority to 1,2,8,10,12,21,25.
   
2.  Use Table 1.1 on page 31 in Sebesta’s book to evaluate the C programming language
   
3.  Use Table 1.1 on page 31 in Sebesta’s book to evaluate the C# or Java programming language (optional)
   
4.  Do Fisher et al. exercise 3 on page 26 (exercise 5 page 55 in GE)

5.  Do Fisher et al. exercise 7 on page 28 (exercise 10 on page 57 in GE) (optional)


# Answers
## 1. Sebesta Review Questions

### 1. Why is it useful for a programmer to have the ability to learn new ­languages, even though he or she may have a good knowledge of a number of programming languages?
Being aware of a wider variety of programming language features can reduce the limitations of constructing algorithms in software development. Programmers can increase the range of their software development thought processes by learning new language constructs. Often language constructs can be **simulated in other languages** that do not support those constructs directly.

### 2. Why is it essential to choose an appropriate programming language for a specific software solution?
As some scenarios can call for specific functionality, choosing the appropriate language can be very helpful. Some programming languages could implement certain functions that are needed by default, leading to improved programming time as the developer will not have to implement the functions themselves.

### 8.How does the overall simplicity of a programming language affect its readability?
If a programming language has a **high number of basic constructs** it is a lot more difficult for the reader and programmer to communicate the code. The programmer and reader might not learn the same subset of functionalities of the large programming languages, meaning the reader might be unfamiliar with the constructs used in the program.

Another problem is **feature multiplicity**. If a programming languages has multiple ways for accomplishing the same operation, the language can seem more complicated.

A third problem is **operator overloading**. Operator overloading is when a programming languages has multiple meanings for a single operator symbol. This can often be useful, however it can also hinder readability if users are allowed to create their own overloading and do not do it sensibly. Overloading meaning the operator symbol being used in more cases. An example of a good case of operator overloading is using the *+* sign for addition between integers, but also for addition between floating points.

Finally, simplicity can be carried too far. If a programming language becomes too simple program structure can be less obvious and the readability will fall.

### 10. Why does too much orthogonality cause problems?
Too much orthogonality leads to excessive complexity, with an unnecessary amount of combinations. Even though the combinations might be simple, the huge amount of combinations lead to high complexity.

### 12. Why is too much orthogonality a detriment to “writability”?
If a program has a excessively high amounts of combinations that are legal. Errors in programs can go unnoticed as nearly any combination of primitives is legal. This can lead to programs that cannot be discovered by the compiler. 

### 21. What are the three fundamental features of an ­object­-oriented programming language?
[[Abstract data types]], [[inheritance]] and [[dynamic binding]].


### 25. Which produces faster program execution, a compiler or a pure interpreter?
A compiler is 10 to 100 times faster than pure interpretation. 

However Pure Interpretation has the advantage of allowing easy debugging, as the interpreter can tell exactly where in the source code the error occurs.

## 2. Use Table 1.1 on page 31 in Sebesta’s book to evaluate the C programming language
I dont get it

| Characteristic          | Readability | Writability | Reliability |
| ----------------------- | ----------- | ----------- | ----------- |
| Simplicity              |             |             |             |
| Orthogonality           |             |             |             |
| Data Types              |             |             |             |
| Syntax Design           |             |             |             |
| Support for Abstraction |             |             |             |
| Expressivity            |             |             |             |
| Type Checking           |             |             |             |
| Exception Handling      |             |             |             |
| Restricted Aliasing     |             |             |             |


## 3. Use Table 1.1 on page 31 in Sebesta’s book to evaluate the C# or Java programming language (optional)
Same

## 4.  Do Fisher et al. exercise 3 on page 26 (exercise 5 page 55 in GE)


## 5.  Do Fisher et al. exercise 7 on page 28 (exercise 10 on page 57 in GE) (optional)

